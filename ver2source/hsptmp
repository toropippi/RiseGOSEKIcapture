#packopt hide 1

#const wx 384//キャプチャサイズ
#const wy 336//キャプチャサイズ
#const bdr 2//ボーダーサイズ、bgscrのくり抜きはボーダーこの3倍になる
//      スキル1,スキル2 ,Lv1     ,Lv2     ,スロ画像,紙の護石,スロット,装備スキル
xylist=34  ,180,34  ,256,271 ,214,271 ,290,229 ,78 ,63  ,6  ,6   ,86 ,121 ,142
szlist=220 ,32 ,220 ,32 ,96  ,36 ,96  ,36 ,132 ,44 ,140 ,36 ,128 ,32 ,132 ,30

#include "HSPCL64.as"
#include "MHRInit_cui.hsp"
#include "MHRModule.hsp"
#include "OpenCL.hsp"

gosub*ValArraySetting
gosub*ScreenSetting
gosub*clfirstInit
gosub*Fileload
gosub*Fileload2
ModuInit
gosub*cmdlinekaitou

notesel GOSEKIcapture2Setting
noteget capx,3//1122
noteget capy,5//236
capx=int(capx)
capy=int(capy)

	//メインループ
	repeat fnum
	gosub*capture
	gosub*splitgrphc//1枚のキャプチャ画像から各領域を切り抜く
	gosub*GPUTask
	gosub*levelchk//スキルのレベルチェック
	gosub*ratechk//護石のレートチェック
	gosub*skillchk//スキル画像マッチ結果取得、順位表更新
	gosub*slotchk//スロット画像マッチ結果取得
	gosub*txtedit//スキル内容出力
	loop

bsave "GOSEKICUIout.txt",outtxt_bk,strlen(outtxt_bk)
end

//スクリーンキャプチャ
*capture
	buffer 29:picload flst.cnt
	x29=ginfo(12)
	y29=ginfo(13)
	if (x29==1920)&(y29==1280){
		gsel 3
		pos 0,0
		gcopy 29,capx,capy,wx,wy
	}else{
		buffer 30,1920,1080
		pos 0,0
		gzoom 1920,1080,29,0,0,x29,y29,1
		gsel 3
		pos 0,0
		gcopy 30,capx,capy,wx,wy
	}
	return

//1枚のキャプチャ画像から各領域を切り抜く
*splitgrphc
	gsel 4
	pos 0,0
	p1=xylist.(0*2)-bdr
	p2=xylist.(0*2+1)-bdr
	p3=szlist.(0*2)+bdr*2
	p4=szlist.(0*2+1)+bdr*2
	gcopy 3,p1,p2,p3,p4
	
	pos 0,szlist.1+bdr*2
	p1=xylist.(1*2)-bdr
	p2=xylist.(1*2+1)-bdr
	p3=szlist.(1*2)+bdr*2
	p4=szlist.(1*2+1)+bdr*2
	gcopy 3,p1,p2,p3,p4

	gsel 8
	pos 0,0
	p1=xylist.(4*2)-bdr
	p2=xylist.(4*2+1)-bdr
	p3=szlist.(4*2)+bdr*2
	p4=szlist.(4*2+1)+bdr*2
	gcopy 3,p1,p2,p3,p4

	if cnt==0{
		gsel 4
		bmpsave "キャプチャーskill.bmp"
		gsel 8
		bmpsave "キャプチャーslot.bmp"
	}
	
	gosub*SklFrame
	gosub*SlotFrame
	return

*GPUTask
	gosub*Match100
	gosub*MatchSlot44
	HCLFlush
	return

*skillchk
	HCLReadBuffer Sum2Result,h2res,SKLNUM*2*4
	memcpy h2res0,h2res,SKLNUM*4,0,0
	memcpy h2res1,h2res,SKLNUM*4,0,SKLNUM*4

	HCLReadBuffer blackwhitescore,h_bw,16
	h2res0.SKLNUM=BlackCalc(h_bw.0)
	h2res1.SKLNUM=BlackCalc(h_bw.1)
	h2res0.(SKLNUM+1)=WhiteCalc(h_bw.2)
	h2res1.(SKLNUM+1)=WhiteCalc(h_bw.3)
	
	sortval h2res0,0
	memcpy out0,h2res0,SKLNUM2*4
		repeat 39
		sortget out0.(cnt+SKLNUM2),cnt
		loop

	sortval h2res1,0
	memcpy out1,h2res1,SKLNUM2*4
		repeat 39
		sortget out1.(cnt+SKLNUM2),cnt
		loop

	return

*slotchk
	HCLReadBuffer Sum4Result,slsc

		repeat 3
		slotout.cnt=-1
		mnsc=slidersc/100
		if mnsc>4000000:mnsc=2000000000
		
		ccnt=cnt
			repeat 4
			_slsc=slsc.(cnt*3+ccnt)
			if mnsc>_slsc:mnsc=_slsc:slotout.ccnt=cnt
			loop
		slotoutsc.cnt=mnsc
		loop
	
	return

*levelchk
	gsel 3
		repeat 2
		flg=0
		bcnt=0
		xofst=xylist.(cnt*2)+19
		yofst=xylist.(cnt*2+1)+56
			repeat 120
			pget xofst+cnt*2,yofst
			if ginfo_b>100{
				bcnt++
				flg=0
			}else{
				flg++
				if flg>6:break
			}
			loop
		
		sklLV.cnt=(bcnt+5)/9
		sklLV_debug.cnt=bcnt
		loop
	//7-16-26
	return

*ratechk
	gsel 3
		repeat 7
		ratesc.cnt=0
		loop
		
	xofst=xylist.8+42
	yofst=xylist.9-8
	pgetcnt=0
		repeat 3
		yofst-=2
			repeat 50
			if pgetcnt>12:break
			pget xofst+cnt*2,yofst
			sumcol=ginfo_r+ginfo_g+ginfo_b
			if sumcol>140{
				toHSV rateH,_S,_V,ginfo_r,ginfo_g,ginfo_b
				rateH=HtoRate(rateH)
				if rateH!=-1{
					ratesc.(rateH-1)++
					pgetcnt++
				}
			}
			loop
		loop

	maxval=0
	ratesc.7=-1
		repeat 7
		if ratesc.cnt>maxval:maxval=ratesc.cnt:ratesc.7=cnt
		loop
	return


*txtedit
	out1line=""
	out1line+=""+SLLLS.(out0.SKLNUM2)+","+sklLV.0+","
	out1line+=""+SLLLS.(out1.SKLNUM2)+","+sklLV.1+","
	out1line+=""+slotout.0+","+slotout.1+","+slotout.2+","
	out1line+=""+(ratesc.7+1)+"\n"
	/*
	if last_out1line!=out1line{
		if out0.SKLNUM2<SKLNUM{
			if out0.0<2000000000{
				if sklLV.0>=1{
					if (slotout.0>=0)&(slotout.1>=0)&(slotout.2>=0){
						gosub*dupcheck
						last_out1line=out1line//追加しなくても認識はしていた
						if dupcheckflag==0{//追加していいなら
							outtxt+=out1line
							outtxt_bk+=out1line
							goseki_count++
							if ONorOFFswitch==0{//更新
								gsel 2
								objprm msbxmainid,outtxt
							}
						}
					}
				}
			}
		}
	}*/
	
	outtxt_bk+=out1line
	return

*cmdlinekaitou
	sdim dc,strlen(dir_cmdline)+4096
	dc=dir_cmdline
	strrep dc,"  "," "
	strrep dc," ","\n"
	notesel dc
		repeat 10
		noteget p1,0
		if p1==""{
			notedel 0
		}else{
			break
		}
		loop
	bsave "コマンドライン引数.txt",dc,strlen(dc)
	notesel dc
	fnum=noteinfo(0)
	sdim flst,1024,fnum
		repeat fnum
		noteget p1,cnt
		flst.cnt=p1
		loop
	return
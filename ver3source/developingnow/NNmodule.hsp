//MatrixModuleと抱き合わせで使う前提のモジュール

#module MatIOmodule
#deffunc MatIOmodule_Init
	if IMGprg==0{
		IMGprg=HCLCreateProgramWithSource({"
		__kernel void gselToBufferFloat(__global uchar *buf,__global float *vout) 
		{
			uint id = get_global_id(0);
			uchar _b=buf[id*3];
			uchar _g=buf[id*3+1];
			uchar _r=buf[id*3+2];
			float ans=(float)(_g)+(float)(_b)+(float)(_r);
			vout[id]=ans/(255*3);
		}
		"})
		krngselToBufferFloat=HCLCreateKernel(IMGprg,"gselToBufferFloat")
	}
	return


//gselで指定した画面をrgbを1色にしてfloat型に、さらに0.0〜1.0に色が収まるように
//memidをstrで返す
#defcfunc gselToBufferFloat1 int gid
	if IMGprg==0:MatIOmodule_Init
	cg=ginfo(3)
	gsel gid
	mref i,66
	vramchar3=HCLCreateBufferFrom(i)
	vout=HCLCreateBuffer(ginfo(12)*ginfo(13)*4)//float型を想定
	HCLSetkrns krngselToBufferFloat,vramchar3,vout
	HCLDoKrn1_sub krngselToBufferFloat,ginfo(12)*ginfo(13),64
	HCLReleaseBuffer vramchar3
	gsel cg
	return str(vout)
//gselで指定した画面をrgbを1色にしてfloat型に、さらに0.0〜1.0に色が収まるように
//memidを入力する形式
#deffunc gselToBufferFloat2 int gid,str vramids
	vramid=int64(vramids)
	if IMGprg==0:MatIOmodule_Init
	cg=ginfo(3)
	gsel gid
	mref i,66
	vramchar3=HCLCreateBufferFrom(i)
	HCLSetkrns krngselToBufferFloat,vramchar3,vramid
	HCLDoKrn1_sub krngselToBufferFloat,ginfo(12)*ginfo(13),64
	HCLReleaseBuffer vramchar3
	gsel cg
	return
	

//name,memid,行,列
#deffunc npsave str fname,var A
	HCLdim_i32FromBuffer hostdata,A
	dim header,32
	header.0=1297436307
	header.1=88400
	header.2=662372470
	sdim saveout1,256
	raw=HCLBLAS_Get2DShape(A,0)
	col=HCLBLAS_Get2DShape(A,1)
	saveout1="descr': '<f4', 'fortran_order': False, 'shape': ("+raw+", "+col+"), }"
		repeat 128-13
		if strlen(saveout1)<128-13{
			saveout1+=" "
		}
		loop
	memcpy header,saveout1,128-12-1,12,0
	poke header,127,10
	bsave fname,header,128
	bsave fname,hostdata,varsize(hostdata),128
	return

//64bit intのmemidをいれればいいやつ
#deffunc npload str fname,var A
	exist fname
	sz=strsize-128
	dim hostdata,strsize/4
	bload fname,hostdata
	HCLWriteBuffer A,hostdata,sz,0,128
	return
#global
















#module NNpartsmodule
#deffunc NNpartsmodule_Init
	
	if prgAtoY==0{
		prgAtoY=HCLCreateProgramWithSource({"
		inline void atomic_maxf(volatile __global float *g_val, float myValue)
		{
		  float cur;
		  while (myValue > (cur = *g_val))
		    myValue = atomic_xchg(g_val,max(cur,myValue));
		}
		
		float atom_add_float(__global float* const address, const float value)
		{
		  uint oldval, newval, readback;
		  *(float*)&oldval = *address;
		  *(float*)&newval = (*(float*)&oldval + value);
		  while ((readback = atom_cmpxchg((__global uint*)address, oldval, newval)) != oldval) {
		    oldval = readback;
		    *(float*)&newval = (*(float*)&oldval + value);
		  }
		  return *(float*)&oldval;
		}

		__kernel void krnAtoY1(__global float *A,uint colnum,__global float *maxvram)
		{
			uint id = get_global_id(0);
			uint id2 = id/colnum;
			atomic_maxf(&maxvram[id2],A[id]-30.0);
		}
		__kernel void krnAtoY2(__global float *A,__global float *Y,uint colnum,__global float *maxvram,__global float *sumexpvram)
		{
			uint id = get_global_id(0);
			uint id2 = id/colnum;
			float e = exp(A[id]-maxvram[id2]);
			Y[id] = e;
			atom_add_float(&sumexpvram[id2],e);
		}
		__kernel void krnAtoY3(__global float *Y,uint colnum,__global float *sumexpvram)
		{
			uint id = get_global_id(0);
			uint id2 = id/colnum;
			Y[id] /= sumexpvram[id2];
		}
		"})
		krnAtoY1=HCLCreateKernel(prgAtoY,"krnAtoY1")
		krnAtoY2=HCLCreateKernel(prgAtoY,"krnAtoY2")
		krnAtoY3=HCLCreateKernel(prgAtoY,"krnAtoY3")
	}
	return

//aをもとにyを計算する
#deffunc AToY var A, var Y
	if prgAtoY==0:NNpartsmodule_Init

	rawnum=int(HCLBLAS_Get2DShape(A,0))
	colnum=int(HCLBLAS_Get2DShape(A,1))
	
	sz=int(rawnum*colnum)
	maxvram=HCLCreateBuffer(rawnum*4)
	sumexpvram=HCLCreateBuffer(rawnum*4)
	
	HCLFillBuffer maxvram,float(0.0)//0.0うめ
	HCLFillBuffer sumexpvram,float(0.0)//0.0うめ
	
	HCLSetkrns krnAtoY1,A,colnum,maxvram
	HCLSetkrns krnAtoY2,A,Y,colnum,maxvram,sumexpvram
	HCLSetkrns krnAtoY3,Y,colnum,sumexpvram

	HCLDoKrn1_sub krnAtoY1,sz,64
	HCLDoKrn1_sub krnAtoY2,sz,64
	HCLDoKrn1_sub krnAtoY3,sz,64

	HCLReleaseBuffer maxvram
	HCLReleaseBuffer sumexpvram
	return
#global


















#module BatchNormalization gamma,beta,momentum,running_mean,running_var,xc,std,dgamma,dbeta,prg,krn1,shape1,xn,ccnt

#modterm
	HCLReleaseBuffer gamma
	HCLReleaseBuffer beta
	HCLReleaseBuffer running_mean
	HCLReleaseBuffer running_var
	HCLReleaseBuffer xc
	HCLReleaseBuffer std
	HCLReleaseBuffer dgamma
	HCLReleaseBuffer dbeta
	HCLReleaseBuffer xn
	return

#modinit int shape1_,int ccnt_,str loadpathname
	shape1=shape1_
	ccnt=ccnt_
	momentum=float(0.9)
	
	gamma=HCLCreateBuffer(shape1*4)
	beta=HCLCreateBuffer(shape1*4)
	dgamma=HCLCreateBuffer(shape1*4)
	dbeta=HCLCreateBuffer(shape1*4)
	running_mean=HCLCreateBuffer(shape1*4)
	running_var=HCLCreateBuffer(shape1*4)
	xc=HCLCreateBuffer(shape1*256*4)
	xn=HCLCreateBuffer(shape1*256*4)
	std=HCLCreateBuffer(shape1*4)
	
	
	HCLIncRefcntCLBufferId gamma,beta,dgamma,dbeta,running_mean,running_var,xc,std,xn
	
	npload ""+loadpathname+"bn"+str(ccnt)+"_gamma.npy",gamma
	npload ""+loadpathname+"bn"+str(ccnt)+"_beta.npy" ,beta
	npload ""+loadpathname+"bn"+str(ccnt)+"_running_mean.npy",running_mean
	npload ""+loadpathname+"bn"+str(ccnt)+"_running_var.npy",running_var

	prg=HCLCreateProgramWithSource({"
	__kernel void krn1(__global float *X,__global float *Xout
	,__global float *running_mean,__global float *running_var
	,__global float *gamma,__global float *beta) 
	{
		uint id = get_global_id(0);
		uint id2 = id%"}+str(shape1)+{";
		float x1 = X[id] - running_mean[id2];
		x1 = x1/sqrt(0.0000001+running_var[id2]);
		Xout[id] = gamma[id2]*x1+beta[id2];
	}
	"})
	krn1=HCLCreateKernel(prg,"krn1")
	HCLSetkrns krn1,int64(0),int64(0),running_mean,running_var,gamma,beta
	return


#modfunc BNsave str loadpathname
	npsave ""+loadpathname+"bn"+str(ccnt)+"_gamma.npy",gamma
	npsave ""+loadpathname+"bn"+str(ccnt)+"_beta.npy" ,beta
	npsave ""+loadpathname+"bn"+str(ccnt)+"_running_mean.npy",running_mean
	npsave ""+loadpathname+"bn"+str(ccnt)+"_running_var.npy",running_var
	return

#modfunc BNforwrd var Matmin,var Matmout,int train_flg
	
	if train_flg==1{//学習時
		temv=HCLCreateBuffer(256*4)
		HCLFillBuffer temv,float(1.0/256)
		
		mu=HCLBLAS_sgemv(HCLBLAS_sT(Matmin),temv)
		HCLDoXf "B[i]=A[i]-C[i%s];",Matmin,xc,mu,shape1
		xc2=HCLDoXf("OUT[i]=A[i]*A[i];",xc)
		HCLBLAS_Set2DShape xc2,256,shape1
		
		var=HCLBLAS_sgemv(HCLBLAS_sT(xc2),temv)
		HCLDoXf "O[i]=sqrt(A[i]+0.0000001);",var,std
		HCLDoXf "C[i]=A[i]/B[i%s];",xc,std,xn,shape1
		
		HCLDoXf "A[i]=A[i]*a+(1.0-a)*B[i];",running_mean,mu,momentum
		HCLDoXf "A[i]=A[i]*a+(1.0-a)*B[i];",running_var,var,momentum

		HCLDoXf "O[i]=A[i]*B[i%s]+C[i%s];",xn,gamma,beta,Matmout,shape1
		
		/*
            # 正規化の計算
            mu = x.mean(axis=0)  # 平均
            xc = x - mu  # 偏差
            var = np.mean(xc ** 2, axis=0)  # 分散
            std = np.sqrt(var + 10e-7)  # 標準偏差
            xn = xc / std  # 標準化:式(6.7)

            # 計算結果を(逆伝播用に)インスタンス変数として保存
            self.batch_size = x.shape[0]
            self.xc = xc  # 偏差
            self.xn = xn  # 標準化データ
            self.std = std  # 標準偏差
            self.running_mean = self.momentum * self.running_mean + (1 - self.momentum) * mu  # 過去の平均の情報
            self.running_var = self.momentum * self.running_var + (1 - self.momentum) * var  # 過去の分散の情報
			//# 再変換
			out = self.gamma * xn + self.beta  # 式(6.8)
		*/
	}else{  //# テスト時
		/*
            xc = x - self.running_mean
            xn = xc / np.sqrt(self.running_var + 10e-7)  # 標準化:式(6.7')
			//# 再変換
			//out = self.gamma * xn + self.beta  # 式(6.8)
		*/
		rawnum=HCLBLAS_Get2DShape(Matmin,0)
		colnum=HCLBLAS_Get2DShape(Matmin,1)
		HCLSetkrns krn1,Matmin,Matmout
		HCLDokrn1_sub krn1,int(rawnum*colnum),64
	}
	return


#modcfunc BNbackward var Matmin
	raw_ = HCLBLAS_Get2DShape(Matmin,0)
	temv = HCLCreateBuffer(raw_*4)
	HCLFillBuffer temv,float(1.0)
	HCLBLAS_sgemv dbeta,HCLBLAS_sT(Matmin),temv
	
	HCLBLAS_Set2DShape xn,256,shape1
	HCLDoXf "A[i]*=B[i];",xn,Matmin
	HCLBLAS_sgemv dgamma,HCLBLAS_sT(xn),temv

	dxn = HCLDoXf("OUT[i]=A[i]*B[i%s];",Matmin,gamma,shape1)
	dxc = HCLDoXf("OUT[i]=A[i]/B[i%s];",dxn,std,shape1)

	T = HCLDoXf("OUT[i]=-A[i]*B[i]/(C[i%s]*C[i%s]);",dxn,xc,std,shape1)
	HCLBLAS_Set2DShape T,256,shape1
	dstd = HCLBLAS_sgemv(HCLBLAS_sT(T),temv)

	dvar=HCLDoXf("OUT[i]=A[i]*0.5/B[i];",dstd,std)

	HCLDoXf "A[i]+=(2.0/256)*B[i]*C[i%s];",dxc,xc,dvar,shape1

	HCLBLAS_Set2DShape dxc,256,shape1
	dmu=HCLBLAS_sgemv(HCLBLAS_sT(dxc),temv)

	dx=HCLDoXf("OUT[i]=A[i]-B[i%s]/256;",dxc,dmu,shape1)
	
/*
        # 微分の計算
        dbeta = dout.sum(axis=0)  # 調整後の平均
        dgamma = np.sum(self.xn * dout, axis=0)  # 調整後の標準偏差
        dxn = self.gamma * dout  # 正規化後のデータ
        dxc = dxn / self.std  # 偏差
        dstd = -np.sum((dxn * self.xc) / (self.std * self.std), axis=0)  # 標準偏差
        dvar = 0.5 * dstd / self.std  # 分散
        dxc += (2.0 / self.batch_size) * self.xc * dvar  # 偏差
        dmu = np.sum(dxc, axis=0)  # 平均
        dx = dxc - dmu / self.batch_size  # 入力データ

        # インスタンス変数に保存
        self.dgamma = dgamma
        self.dbeta = dbeta
*/
	return str(dx)


#modfunc BNmodyf double alpha
	HCLDoXf "A[i]-=B[i]*a;",gamma,dgamma,float(alpha)
	HCLDoXf "A[i]-=B[i]*a;",beta,dbeta,float(alpha)
	return

#global
#include "hspcl64.as"
#include "NNmodule.hsp"
	randomize
	HCLinit
	SKLALLSTR="ＫＯ術","アイテム使用強化","ガード強化","ガード性能","キノコ大好き","ジャンプ鉄人","スタミナ急速回復","スタミナ奪取","ひるみ軽減","フルチャージ","ブレ抑制","ボマー","ランナー","火事場力","火属性攻撃強化","火耐性","会心撃【属性】","回避距離ＵＰ","回避性能","回復速度","滑走強化","貫通弾・貫通矢強化","気絶耐性","鬼火纏","逆恨み","逆襲","強化持続","業物","見切り","幸運","広域化","攻めの守勢","攻撃","高速変形","剛刃研磨","散弾・拡散矢強化","死中に活","耳栓","弱点特効","集中","匠","乗り名人","植生学","心眼","水属性攻撃強化","水耐性","睡眠属性強化","睡眠耐性","精霊の加護","早食い","装填拡張","装填速度","速射強化","属性やられ耐性","体術","体力回復量ＵＰ","耐震","弾丸節約","弾導強化","地質学","挑戦者","超会心","通常弾・連射矢強化","泥雪耐性","笛吹き名人","砥石使用高速化","特殊射撃強化","毒属性強化","毒耐性","鈍器使い","納刀術","破壊王","剥ぎ取り鉄人","爆破やられ耐性","爆破属性強化","抜刀術【技】","抜刀術【力】","反動軽減","飛び込み","氷属性攻撃強化","氷耐性","不屈","風圧耐性","腹減り耐性","壁面移動","泡沫の舞","砲術","砲弾装填","防御","麻痺属性強化","麻痺耐性","満足感","陽動","雷属性攻撃強化","雷耐性","龍属性攻撃強化","龍耐性","力の解放","渾身","翔蟲使い","達人芸","NULL"

	//#N = 415676  # データの数
	//M = 512 # 1層
	//M2 = 256 # 2層
	//D = 128*22 # 入力層
	//K = 102
	alpha=0.02
	N=256//=1batch
	mlpLayerNum=4
	dim mlpLayerNode,mlpLayerNum
	mlpLayerNode=128*22,512,256,102

	gosub*GPUデバイスせセット
	gosub*X作成
	gosub*T作成
	DEBUGLOAD=0
	gosub*cpu側にデータ全部載せる
	gosub*テストデータXT
	gosub*loadwv//WV作成ロード
	gosub*make_bzbnb

	//save
	//npsave "H:\\mhrchap\\開発フォルダ\\7ディープラーニング\\matT.npy",matT
	//npsave "H:\\mhrchap\\開発フォルダ\\7ディープラーニング\\matX.npy",matX
	if DEBUGLOAD!=0{
		bsave "h_ansT",h_ansT
		bufnum=(allpngnum*2+429)/430
			repeat bufnum
			gsel 10+cnt
			bmpsave ""+(10+cnt)+".bmp"
			loop
	}
	gsel 0


	//メイン計算
	//まいループでランダムにチョイスして256ミニバッチ学習

	h_ce=float(0.0)
		repeat 1199
		maincnt=cnt
		if h_ce<float(0.03){
			gosub*make_rndchiceXT
			//screen 3,128,22*256:pos 0,0:gcopy 9,0,0,128,22*256
			gsel 0
			title ""+maincnt+""
			color 255,255,255
			boxf
			color 0,0,0
			pos 0,0
		}
		//テスト
		trainingflg=0
		matX_=matXtest
		gosub*FNNmain
		matT_=matTtest
		gosub*CE_FFN
		ce_test=ce
		//学習
		trainingflg=1
		matX_=matX
		gosub*FNNmain
		matT_=matT
		gosub*CE_FFN
		h_cetest=HCLReadIndex_fp(ce_test,0)
		h_ce=HCLReadIndex_fp(ce,0)
		mes ""+h_ce+"\t"+h_cetest+""
		//gosub*結果
		gosub*dCE_FNN
		HCLGarbageCollectionNow
		await 1
		if maincnt<400:await 10
		if maincnt<100:await 20

		getkey key,27
		if key:gosub*WVBNsave:end
		if maincnt>230{
			if h_cetest<float(0.00004):gosub*WVBNsave:stop
		}
		loop

	end
	stop




*結果
	trainingflg=0
	HCLdim_fpFromBuffer result,matZ.(mlpLayerNum-2)
	sdim outstr,65536*16
		repeat N
		w=cnt
		maxd=float(-100.0)
		maxi=-1
			repeat 102
			sc=result.(w*102+cnt)
			if maxd<sc{
				maxd=sc
				maxi=cnt
			}
			loop
		if maxi<0:dialog "a"+maxi+" "+sc+"",0:end

		if h_ansT2.cnt==maxi{
			outstr+="●"
		}else{
			outstr+="×"
		}
		outstr+=""+(str(SKLALLSTR.(h_ansT2.cnt)))+"\t"+SKLALLSTR.maxi+"\t"+maxd+"\n"
		loop
	
	screen 2,640,480
	pos 0,0
	mesbox outstr,630,470,5
	gsel 0
	return



*テストデータXT
	//X
	matXtest=HCLCreateBuffer(N*mlpLayerNode.0*4)
	HCLBLAS_Set2DShape matXtest,N,mlpLayerNode.0
	HCLIncRefcntCLBufferId matXtest
	
	gsel 9
	testidstart=allpngnum*2-256
		repeat 256
		cc=(testidstart+cnt)
		xx=28
		yy=8
		pos 0,255*22-22*cnt
		gcopy 10+cc/430,xx,yy+38*(cc\430),128,22
		loop
							buffer 8:picload "Z:\\test00.png"//はぎとり=72
							buffer 7:picload "Z:\\test01.png"//逆襲=25
							buffer 6:picload "Z:\\test02.png"//見切り=28
							buffer 5:picload "Z:\\test03.png"//壁面移動=84
							gsel 9
								repeat 256
								pos 0,255*22-22*cnt
								gcopy 8-cnt/64,0,0,128,22
								loop
	gselToBufferFloat2 9,str(matXtest)
	gsel 0

	//T
	matTtest=HCLCreateBuffer(N*mlpLayerNode.(mlpLayerNum-1)*4)
	HCLIncRefcntCLBufferId matTtest
	HCLBLAS_Set2DShape matTtest,N,mlpLayerNode.(mlpLayerNum-1)

	dim h_ansT3,256
		repeat 256
		h_ansT3.cnt=h_ansT.(cnt+testidstart)
		loop
								repeat 64,0  :h_ansT3.cnt=72:loop
								repeat 64,64 :h_ansT3.cnt=25:loop
								repeat 64,128:h_ansT3.cnt=28:loop
								repeat 64,192:h_ansT3.cnt=84:loop
	HCLFillBuffer matTtest,float(0)
	HCLDoXi "F0[A[i]+i*102]=1.0;",HCLCreateBufferFrom(h_ansT3),matTtest
	return

*make_rndchiceXT
	//まず全体から256個の重複なしランダムを作成したいが重複なしは大変なので重複ありで
	dim rn,256
		repeat 256
		rn.cnt=(rnd(8192)*8192+rnd(8192))\(allpngnum*2)
		//rn.cnt=(rnd(8192)*8192+rnd(8192))\((allpngnum-128)*2)
		loop
	//X
	gsel 9
	xxcrng=limit((maincnt-190)/5,1,44)
	yycrng=limit((maincnt-190)/9,1,16)
		repeat 256
		xx=28-xxcrng*28/44+rnd(xxcrng)//rnd(44)
		xx=limit(xx,0,44)
		yy=8-yycrng/2+rnd(yycrng)//rnd(16)
		pos 0,255*22-22*cnt
		gcopy 10+rn.cnt/430,xx,yy+38*(rn.cnt\430),128,22
		loop
	//T
	dim h_ansT2,256
		repeat 256
		h_ansT2.cnt=h_ansT.(rn.cnt)
		loop

	//X
	gselToBufferFloat2 9,str(matX)
	
	//T
	HCLFillBuffer matT,float(0)
	HCLDoXi "F0[A[i]+i*102]=1.0;",HCLCreateBufferFrom(h_ansT2),matT
	gsel 0
	return


//matX_に好きなのを代入してgosubしてください
*FNNmain
	HCLBLAS_sgemm matB.0,matX_,matWV.0
		repeat mlpLayerNum-2
		BNforwrd BN.cnt,matB.cnt,matBNB.cnt,trainingflg
		HCLDoXf "A[i]=max(B[i],0.0f);",matZ.cnt,matBNB.cnt
		HCLBLAS_sgemm matB.(cnt+1),matZ.cnt,matWV.(cnt+1)
		loop
	AToY matB.(mlpLayerNum-2),matZ.(mlpLayerNum-2)
	//matZがyに相当
	//matBがaに相当
	return

//matT_に好きなのを代入してgosubしてください
*CE_FFN
	nplgy=HCLDoXf("float x=A[i];if (x<=0.0)x=0.0000000000001;OUT[i]=-log(x)/256;",matZ.(mlpLayerNum-2))
	ce=HCLBLAS_sdot(nplgy,matT_)
	return

//この中でalpha補正もする
*dCE_FNN
	dim64 delta,mlpLayerNum-1
	
	delta.(mlpLayerNum-2) = HCLDoXf("OUT[i]=A[i]-B[i];",matZ.(mlpLayerNum-2),matT)
	raw_ = HCLBLAS_Get2DShape(matZ.(mlpLayerNum-2),0)
	col_ = HCLBLAS_Get2DShape(matZ.(mlpLayerNum-2),1)
	HCLBLAS_Set2DShape delta.(mlpLayerNum-2),raw_,col_

		repeat mlpLayerNum-2
		ccnt2=mlpLayerNum-2-cnt
		ccnt3=mlpLayerNum-3-cnt
		
		delta12_1 = HCLBLAS_sgemm(delta.ccnt2, matWV.ccnt2 ,0,0,1)
		delta12_2 = HCLDoXf("OUT[i]=A[i]*(B[i]>0.0);",delta12_1,matBNB.ccnt3)
		raw_ = HCLBLAS_Get2DShape(delta12_1,0)
		col_ = HCLBLAS_Get2DShape(delta12_1,1)
		HCLBLAS_Set2DShape delta12_2,raw_,col_
		delta.ccnt3 = int64(BNbackward(BN.ccnt3,delta12_2))
		HCLBLAS_Set2DShape delta.ccnt3,raw_,col_
		loop

		repeat mlpLayerNum-2
		ccnt2=mlpLayerNum-2-cnt
		ccnt3=mlpLayerNum-3-cnt
		dv=HCLBLAS_sgemm(delta.ccnt2,matZ.ccnt3 ,1,1,0)//割るN
		HCLDoXf "B[i]/=256;A[i]-=a*B[i];",matWV.ccnt2,dv,float(alpha)
		loop
	
	dw=HCLBLAS_sgemm(delta.0,matX ,1,1,0)//割るN
	HCLDoXf "B[i]/=256;A[i]-=a*B[i];",matWV.0,dw ,float(alpha)

		repeat mlpLayerNum-2
		BNmodyf BN.cnt,alpha
		loop
	return



*make_bzbnb
	//b,zを作る
	//a,yはb,zの最後の要素に対応
	dim64 matB,mlpLayerNum-1
	dim64 matZ,mlpLayerNum-1
	dim64 matBNB,mlpLayerNum-2
	//B,Z
		repeat mlpLayerNum-1
		matB.cnt=HCLCreateBuffer(N*mlpLayerNode.(cnt+1)*4)
		HCLBLAS_Set2DShape matB.cnt,N,mlpLayerNode.(cnt+1)
		matZ.cnt=HCLCreateBuffer(N*mlpLayerNode.(cnt+1)*4)
		HCLBLAS_Set2DShape matZ.cnt,N,mlpLayerNode.(cnt+1)
		HCLIncRefcntCLBufferId matZ.cnt,matB.cnt
		loop
	//Batch normの出力変数 BNB
		repeat mlpLayerNum-2
		matBNB.cnt=HCLCreateBuffer(N*mlpLayerNode.(cnt+1)*4)
		HCLBLAS_Set2DShape matBNB.cnt,N,mlpLayerNode.(cnt+1)
		HCLIncRefcntCLBufferId matBNB.cnt
		loop
	//Batch norm計算クラス＝モジュール変数
		repeat mlpLayerNum-2
		newmod BN,BatchNormalization,mlpLayerNode.(cnt+1),cnt+1,"学習後\\"
		loop
	return

*loadwv
	exist "学習後\\WV0.npy"
	dim host_wv,strsize/4
	bload "学習後\\WV0.npy",host_wv
	
	offsetread=0
	dim64 matWV,mlpLayerNum-1
		repeat mlpLayerNum-1
		sz=mlpLayerNode.cnt*mlpLayerNode.(cnt+1)*4
		matWV.cnt=HCLCreateBuffer(sz)
		HCLWriteBuffer matWV.cnt,host_wv,sz,0,128+offsetread
		HCLBLAS_Set2DShape matWV.cnt,mlpLayerNode.(cnt+1),mlpLayerNode.cnt
		matWV.cnt=HCLBLAS_sT(matWV.cnt)
		offsetread+=sz
		HCLIncRefcntCLBufferId matWV.cnt
		loop
	return


//buffer 10以降全て保存用buffer
//buffer 9は128*22 *256として直接matXに転送できるようにする
*cpu側にデータ全部載せる
	//101-114決め打ちロード
	//正解情報も
	allpngnum=83953
	dim fldr14num,14
	
	buffer 9,128,22*256
	bufnum=(allpngnum*2+429)/430
		repeat bufnum
		buffer 10+cnt,128+44,38*430
		loop
	
	w=0
	filenoval=101
		repeat 14
		ccnt=cnt
		chdir "H:\\mhrchap\\"+(filenoval+cnt)+""
		dirlist p1,"*.png",1
		notesel p1
		fldr14num.cnt=noteinfo(0)
		if DEBUGLOAD==0:continue
			repeat noteinfo(0)
			buffer 1:picload ""+cnt+".png"
			gsel 10+w/430
			pos 0,(w\430)*38
			gcopy 1,762-26,276-8,128+44,38
			w++
			pos 0,(w\430)*38
			gcopy 1,762-26,276-8+51,128+44,38
			w++
			loop
		loop
	chdir s5
		
	if DEBUGLOAD==0{
			repeat bufnum
			gsel 10+cnt
			picload ""+(10+cnt)+".bmp"
			gsel 0
			title ""+cnt+"":await 1
			loop
	}
	title "画像ロード"

	//ここからは正解情報をロード
	gsel 0
	chdir s5
	if DEBUGLOAD!=0{
		gosub*kimeutiloadT
	}else{
		dim h_ansT,allpngnum*2
		bload "h_ansT",h_ansT
	}
	title "正解情報ロード"
	return

*kimeutiloadT
	dim h_ansT,allpngnum*2
	w=0
		repeat 14
		ccnt=cnt
		flnm="H:\\mhrchap\\"+(filenoval+cnt)+"GOSEKICUIout.txt"
		exist flnm
		sdim ansdatastr,strsize
		notesel ansdatastr
		noteload flnm
			repeat fldr14num.cnt
			noteget p1,cnt
			split p1,",",arr
			h_ansT.w=101
				repeat 101
				if SKLALLSTR.cnt==arr.0{
					h_ansT.w=cnt
					break
				}
				loop
			w++
			h_ansT.w=101
				repeat 101
				if SKLALLSTR.cnt==arr.2{
					h_ansT.w=cnt
					break
				}
				loop
			w++
			loop
		loop
	return



*GPUデバイスせセット
	s5=dir_cur
	sdim GOSEKIcapture3Setting,4096
	notesel GOSEKIcapture3Setting
	noteload "GOSEKIcapture3Setting.txt"
	noteget p1,1
	HCLSetDevice int(p1)
	return

*X作成
	matX=HCLCreateBuffer(N*mlpLayerNode.0*4)
	HCLBLAS_Set2DShape matX,N,mlpLayerNode.0
	HCLIncRefcntCLBufferId matX
	return

*T作成
	matT=HCLCreateBuffer(N*mlpLayerNode.(mlpLayerNum-1)*4)
	HCLIncRefcntCLBufferId matT
	HCLBLAS_Set2DShape matT,N,mlpLayerNode.(mlpLayerNum-1)
	return


*WVBNsave
	//WVから
		repeat mlpLayerNum-1
		npsave "学習後2\\matWV"+cnt+".npy",matWV.cnt
		loop
	//Batch normの内部変数
		repeat mlpLayerNum-2
		BNsave BN.cnt,"学習後2\\"
		loop
	return

#module
#deffunc clmemgcopy var dst,var src,int x,int y,int ccnt
	yy=720-22-y
		repeat 22
		HCLCopyBuffer dst,src,128*4,ccnt*128*22*4+cnt*128*4,((yy+cnt)*1280+x)*4
		loop
	return

#global
#include "hspcl64.as"
#include "NNmodule.hsp"
//‚±‚±‚Ü‚Å

	SKLALLSTR="‚j‚np","ƒAƒCƒeƒ€g—p‹­‰»","ƒK[ƒh‹­‰»","ƒK[ƒh«”\","ƒLƒmƒR‘åD‚«","ƒWƒƒƒ“ƒv“Sl","ƒXƒ^ƒ~ƒi‹}‘¬‰ñ•œ","ƒXƒ^ƒ~ƒi’Dæ","‚Ğ‚é‚İŒyŒ¸","ƒtƒ‹ƒ`ƒƒ[ƒW","ƒuƒŒ—}§","ƒ{ƒ}[","ƒ‰ƒ“ƒi[","‰Î–ê—Í","‰Î‘®«UŒ‚‹­‰»","‰Î‘Ï«","‰ïSŒ‚y‘®«z","‰ñ”ğ‹——£‚t‚o","‰ñ”ğ«”\","‰ñ•œ‘¬“x","ŠŠ‘–‹­‰»","ŠÑ’Ê’eEŠÑ’Ê–î‹­‰»","‹Câ‘Ï«","‹S‰Î“Z","‹t¦‚İ","‹tP","‹­‰»‘±","‹Æ•¨","Œ©Ø‚è","K‰^","Lˆæ‰»","U‚ß‚Ìç¨","UŒ‚","‚‘¬•ÏŒ`","„nŒ¤–","U’eEŠgU–î‹­‰»","€’†‚ÉŠˆ","¨ğ","ã“_“ÁŒø","W’†"," ","æ‚è–¼l","A¶Šw","SŠá","…‘®«UŒ‚‹­‰»","…‘Ï«","‡–°‘®«‹­‰»","‡–°‘Ï«","¸—ì‚Ì‰ÁŒì","‘H‚¢","‘•“UŠg’£","‘•“U‘¬“x","‘¬Ë‹­‰»","‘®«‚â‚ç‚ê‘Ï«","‘Ìp","‘Ì—Í‰ñ•œ—Ê‚t‚o","‘Ïk","’eŠÛß–ñ","’e“±‹­‰»","’n¿Šw","’§íÒ","’´‰ïS","’Êí’eE˜AË–î‹­‰»","“Dá‘Ï«","“J‚«–¼l","“uÎg—p‚‘¬‰»","“ÁêËŒ‚‹­‰»","“Å‘®«‹­‰»","“Å‘Ï«","“İŠíg‚¢","”[“p","”j‰ó‰¤","”‚¬æ‚è“Sl","”š”j‚â‚ç‚ê‘Ï«","”š”j‘®«‹­‰»","”²“py‹Zz","”²“py—Íz","”½“®ŒyŒ¸","”ò‚Ñ‚İ","•X‘®«UŒ‚‹­‰»","•X‘Ï«","•s‹ü","•—ˆ³‘Ï«","• Œ¸‚è‘Ï«","•Ç–ÊˆÚ“®","–A–—‚Ì•‘","–Cp","–C’e‘•“U","–hŒä","–ƒáƒ‘®«‹­‰»","–ƒáƒ‘Ï«","–‘«Š´","—z“®","—‹‘®«UŒ‚‹­‰»","—‹‘Ï«","—´‘®«UŒ‚‹­‰»","—´‘Ï«","—Í‚Ì‰ğ•ú","ŸÓg","ãÄå³g‚¢","’BlŒ|","NULL"

	//#N = 415676  # ƒf[ƒ^‚Ì”
	//M = 512 # 1‘w
	//M2 = 256 # 2‘w
	//D = 128*22 # “ü—Í‘w
	//K = 102
	alpha=0.3
	
	N=128*2//7100*2
	mlpLayerNum=4
	dim mlpLayerNode,mlpLayerNum
	mlpLayerNode=128*22,512,256,102
	
	//GPUƒfƒoƒCƒX‚¹ƒZƒbƒg
	HCLinit
	sdim GOSEKIcapture3Setting,4096
	notesel GOSEKIcapture3Setting
	noteload "GOSEKIcapture3Setting.txt"
	noteget p1,1
	HCLSetDevice int(p1)
	
	
	//Xì¬
	matX=HCLCreateBuffer(N*mlpLayerNode.0*4)
	HCLBLAS_Set2DShape matX,N,mlpLayerNode.0
	HCLIncRefcntCLBufferId matX
	gosub*kimeutiload
	HCLBLAS_Set2DShape matX,N,mlpLayerNode.0
	//npsave "matX.npy",matX
	
	//Tì¬ƒ[ƒh
	matT=HCLCreateBuffer(N*mlpLayerNode.(mlpLayerNum-1)*4)
	gosub*kimeutiloadT//dim h_ansT,N‚ÉŒ‹‰Ê‚ª‚Í‚¢‚é
	HCLFillBuffer matT,float(0)
	HCLDoXi "F0[A[i]+i*102]=1.0;",HCLCreateBufferFrom(h_ansT),matT
	HCLIncRefcntCLBufferId matT
	HCLBLAS_Set2DShape matT,N,mlpLayerNode.(mlpLayerNum-1)
	npsave "matT.npy",matT
	
	//WVì¬ƒ[ƒh
	gosub*loadwv
	
	//b,z‚ğì‚é
	//a,y‚Íb,z‚ÌÅŒã‚Ì—v‘f‚É‘Î‰
	dim64 matB,mlpLayerNum-1
	dim64 matZ,mlpLayerNum-1
	dim64 matBNB,mlpLayerNum-2
	
		repeat mlpLayerNum-1
		matB.cnt=HCLCreateBuffer(N*mlpLayerNode.(cnt+1)*4)
		HCLBLAS_Set2DShape matB.cnt,N,mlpLayerNode.(cnt+1)
		matZ.cnt=HCLCreateBuffer(N*mlpLayerNode.(cnt+1)*4)
		HCLBLAS_Set2DShape matZ.cnt,N,mlpLayerNode.(cnt+1)
		loop
	//Batch norm‚Ìo—Í•Ï”
		repeat mlpLayerNum-2
		matBNB.cnt=HCLCreateBuffer(N*mlpLayerNode.(cnt+1)*4)
		HCLBLAS_Set2DShape matBNB.cnt,N,mlpLayerNode.(cnt+1)
		loop
	//Batch normŒvZƒNƒ‰ƒXƒ‚ƒWƒ…[ƒ‹•Ï”
		repeat mlpLayerNum-2
		newmod BN,BatchNormalization,mlpLayerNode.(cnt+1),cnt+1,"ŠwKŒã\\"
		loop
	
	gosub*FNNmain
	gosub*CE_FFN
	gosub*dCE_FNN




	HCLdim_fpFromBuffer result,matZ.(mlpLayerNum-2)
	gsel 0
	title "Œ‹‰Êˆ—’†"
	wait 1


	sdim outstr,65536*16
		repeat N
		w=cnt
		maxd=float(0)
		maxi=-1
			repeat 102
			sc=result.(w*102+cnt)
			if maxd<sc{
				maxd=sc
				maxi=cnt
			}
			loop
		outstr+=SKLALLSTR.maxi+"\n"
		loop
	
	pos 0,0
	mesbox outstr,630,470,5
	stop












*FNNmain
	HCLBLAS_sgemm matB.0,matX.0,matWV.0
		repeat mlpLayerNum-2
		BNforwrd BN.cnt,matB.cnt,matBNB.cnt,1
		HCLDoXf "A[i]=max(B[i],0.0f);",matZ.cnt,matBNB.cnt
		HCLBLAS_sgemm matB.(cnt+1),matZ.cnt,matWV.(cnt+1)
		loop
	AToY matB.(mlpLayerNum-2),matZ.(mlpLayerNum-2)
	//matZ‚ªy‚É‘Š“–
	//matB‚ªa‚É‘Š“–
	return

*CE_FFN
	nplgy=HCLDoXf("float x=A[i];if (x<=0.0)x=0.0000000000001;OUT[i]=-log(x)/256;",matZ.(mlpLayerNum-2))
	ce=HCLBLAS_sdot(nplgy,matT)
	return

//‚±‚Ì’†‚Åalpha•â³‚à‚·‚é
*dCE_FNN
	delta2 = HCLDoXf("OUT[i]=A[i]-B[i];",matZ.(mlpLayerNum-2),matT)
	raw_ = HCLBLAS_Get2DShape(matZ.(mlpLayerNum-2),0)
	col_ = HCLBLAS_Get2DShape(matZ.(mlpLayerNum-2),1)
	HCLBLAS_Set2DShape delta2,raw_,col_
	
	delta12_1 = HCLBLAS_sgemm(delta2, matWV.2 ,0,0,1)
	delta12_2 = HCLDoXf("OUT[i]=A[i]*(B[i]>0.0);",delta12_1,matBNB.1)
	raw_ = HCLBLAS_Get2DShape(delta12_1,0)
	col_ = HCLBLAS_Get2DShape(delta12_1,1)
	HCLBLAS_Set2DShape delta12_2,raw_,col_
	delta12_3 = int64(BNbackward(BN.1,delta12_2))
	HCLBLAS_Set2DShape delta12_3,raw_,col_

	delta1_1 = HCLBLAS_sgemm(delta12_3,matWV.1 ,0,0,1)
	delta1_2 = HCLDoXf("OUT[i]=A[i]*(B[i]>0.0);",delta1_1,matBNB.0)
	raw_ = HCLBLAS_Get2DShape(delta1_1,0)
	col_ = HCLBLAS_Get2DShape(delta1_1,1)
	HCLBLAS_Set2DShape delta1_2,raw_,col_
	delta1_3 = int64(BNbackward(BN.0,delta1_2))
	HCLBLAS_Set2DShape delta1_3,raw_,col_

	dv=HCLBLAS_sgemm(delta2,matZ.1 ,1,1,0)//Š„‚éN
	dw2=HCLBLAS_sgemm(delta12_3,matZ.0 ,1,1,0)//Š„‚éN
	dw=HCLBLAS_sgemm(delta1_3,matX ,1,1,0)//Š„‚éN

	HCLDoXf "B[i]/=256;A[i]-=a*B[i];",matWV.0,dw ,float(alpha)
	HCLDoXf "B[i]/=256;A[i]-=a*B[i];",matWV.1,dw2,float(alpha)
	HCLDoXf "B[i]/=256;A[i]-=a*B[i];",matWV.2,dv ,float(alpha)

	screen 2,640,480
	mes HCLReadIndex_fp(matWV.0,0)
	mes HCLReadIndex_fp(matWV.0,209)
	mes HCLReadIndex_fp(matWV.1,0)
	mes HCLReadIndex_fp(matWV.1,209)
	mes HCLReadIndex_fp(matWV.2,0)
	mes HCLReadIndex_fp(matWV.2,209)
	stop
	BNmodyf BN.1,alpha
	BNmodyf BN.0,alpha
	return





*loadwv
	exist "ŠwKŒã\\WV0.npy"
	dim host_wv,strsize/4
	bload "ŠwKŒã\\WV0.npy",host_wv
	
	offsetread=0
	dim64 matWV,mlpLayerNum-1
		repeat mlpLayerNum-1
		sz=mlpLayerNode.cnt*mlpLayerNode.(cnt+1)*4
		matWV.cnt=HCLCreateBuffer(sz)
		HCLWriteBuffer matWV.cnt,host_wv,sz,0,128+offsetread
		HCLBLAS_Set2DShape matWV.cnt,mlpLayerNode.(cnt+1),mlpLayerNode.cnt
		matWV.cnt=HCLBLAS_sT(matWV.cnt)
		offsetread+=sz
		HCLIncRefcntCLBufferId matWV.cnt
		loop
	
	return





//101-114Œˆ‚ß‘Å‚¿ƒ[ƒh
*kimeutiload
	buffer 1
		repeat N/2
		picload "H:\\mhrchap\\113\\"+cnt+".png"
		memG=int64(gselToBufferFloat1(1))
		clmemgcopy matX,memG,752+10,271+5,cnt*2
		clmemgcopy matX,memG,752+10,271+5+51,cnt*2+1
		HCLReleaseBuffer memG
		loop
	
	return

//101-114Œˆ‚ß‘Å‚¿ƒ[ƒh
*kimeutiloadT
	dim h_ansT,N
	exist "H:\\mhrchap\\113GOSEKICUIout.txt"
	sdim ansdatastr,strsize
	notesel ansdatastr
	noteload "H:\\mhrchap\\113GOSEKICUIout.txt"
	
		repeat N/2
		noteget p1,cnt
		split p1,",",arr

		ccnt=cnt*2
		h_ansT.ccnt=101
			repeat 101
			if SKLALLSTR.cnt==arr.0{
				h_ansT.ccnt=cnt
				break
			}
			loop
		ccnt++
		h_ansT.ccnt=101
			repeat 101
			if SKLALLSTR.cnt==arr.2{
				h_ansT.ccnt=cnt
				break
			}
			loop
		loop
	return

#module
#deffunc clmemgcopy var dst,var src,int x,int y,int ccnt
	yy=720-22-y
		repeat 22
		HCLCopyBuffer dst,src,128*4,ccnt*128*22*4+cnt*128*4,((yy+cnt)*1280+x)*4
		loop
	return

#global
//MatrixModuleと抱き合わせで使う前提のモジュール

#module MatIOmodule
#deffunc MatIOmodule_Init
	if IMGprg==0{
		IMGprg=HCLCreateProgramWithSource({"
		__kernel void gselToBufferFloat(__global uchar *buf,__global float *vout) 
		{
			uint id = get_global_id(0);
			uchar _b=buf[id*3];
			uchar _g=buf[id*3+1];
			uchar _r=buf[id*3+2];
			float ans=(float)(_g)+(float)(_b)+(float)(_r);
			vout[id]=ans/(255*3);
		}
		"})
		krngselToBufferFloat=HCLCreateKernel(IMGprg,"gselToBufferFloat")
	}
	return


//gselで指定した画面をrgbを1色にしてfloat型に、さらに0.0〜1.0に色が収まるように
//memidをstrで返す
#defcfunc gselToBufferFloat1 int gid
	if IMGprg==0:MatIOmodule_Init
	cg=ginfo(3)
	gsel gid
	mref i,66
	vramchar3=HCLCreateBufferFrom(i)
	vout=HCLCreateBuffer(ginfo(12)*ginfo(13)*4)//float型を想定
	HCLSetkrns krngselToBufferFloat,vramchar3,vout
	HCLDoKrn1_sub krngselToBufferFloat,ginfo(12)*ginfo(13),64
	HCLReleaseBuffer vramchar3
	gsel cg
	return str(vout)


//name,memid,行,列
#deffunc npsave str fname,var A
	HCLdim_i32FromBuffer hostdata,A
	dim header,32
	header.0=1297436307
	header.1=88400
	header.2=662372470
	sdim saveout1,256
	raw=HCLBLAS_Get2DShape(A,0)
	col=HCLBLAS_Get2DShape(A,1)
	saveout1="descr': '<f4', 'fortran_order': False, 'shape': ("+raw+", "+col+"), }"
		repeat 128-13
		if strlen(saveout1)<128-13{
			saveout1+=" "
		}
		loop
	memcpy header,saveout1,128-12-1,12,0
	poke header,127,10
	bsave fname,header,128
	bsave fname,hostdata,varsize(hostdata),128
	return

//ロードは最初からサイズをあわせないといけない
//こっちはモジュール型ではなく64bit intのmemidをいれればいいやつ
#deffunc nploadm str fname,var A
	exist fname
	sz=strsize-128
	dim hostdata,strsize/4
	bload fname,hostdata
	HCLWriteBuffer A,hostdata,sz,0,128
	return
	
#global
















#module NNpartsmodule
#deffunc NNpartsmodule_Init
	
	if prgAtoY==0{
		prgAtoY=HCLCreateProgramWithSource({"
		inline void atomic_maxf(volatile __global float *g_val, float myValue)
		{
		  float cur;
		  while (myValue > (cur = *g_val))
		    myValue = atomic_xchg(g_val,max(cur,myValue));
		}
		
		float atom_add_float(__global float* const address, const float value)
		{
		  uint oldval, newval, readback;
		  *(float*)&oldval = *address;
		  *(float*)&newval = (*(float*)&oldval + value);
		  while ((readback = atom_cmpxchg((__global uint*)address, oldval, newval)) != oldval) {
		    oldval = readback;
		    *(float*)&newval = (*(float*)&oldval + value);
		  }
		  return *(float*)&oldval;
		}

		__kernel void krnAtoY1(__global float *A,uint colnum,__global float *maxvram)
		{
			uint id = get_global_id(0);
			uint id2 = id/colnum;
			atomic_maxf(&maxvram[id2],A[id]-30.0);
		}
		__kernel void krnAtoY2(__global float *A,__global float *Y,uint colnum,__global float *maxvram,__global float *sumexpvram)
		{
			uint id = get_global_id(0);
			uint id2 = id/colnum;
			float e = exp(A[id]-maxvram[id2]);
			Y[id] = e;
			atom_add_float(&sumexpvram[id2],e);
		}
		__kernel void krnAtoY3(__global float *Y,uint colnum,__global float *sumexpvram)
		{
			uint id = get_global_id(0);
			uint id2 = id/colnum;
			Y[id] /= sumexpvram[id2];
		}
		"})
		krnAtoY1=HCLCreateKernel(prgAtoY,"krnAtoY1")
		krnAtoY2=HCLCreateKernel(prgAtoY,"krnAtoY2")
		krnAtoY3=HCLCreateKernel(prgAtoY,"krnAtoY3")
	}
	return

//aをもとにyを計算する
#deffunc AToY var A, var Y
	if prgAtoY==0:NNpartsmodule_Init

	rawnum=int(HCLBLAS_Get2DShape(A,0))
	colnum=int(HCLBLAS_Get2DShape(A,1))
	
	sz=int(rawnum*colnum)
	maxvram=HCLCreateBuffer(rawnum*4)
	sumexpvram=HCLCreateBuffer(rawnum*4)
	
	HCLFillBuffer maxvram,float(0.0)//0.0うめ
	HCLFillBuffer sumexpvram,float(0.0)//0.0うめ
	
	HCLSetkrns krnAtoY1,A,colnum,maxvram
	HCLSetkrns krnAtoY2,A,Y,colnum,maxvram,sumexpvram
	HCLSetkrns krnAtoY3,Y,colnum,sumexpvram

	HCLDoKrn1_sub krnAtoY1,sz,64
	HCLDoKrn1_sub krnAtoY2,sz,64
	HCLDoKrn1_sub krnAtoY3,sz,64

	HCLReleaseBuffer maxvram
	HCLReleaseBuffer sumexpvram
	return
#global


















#module BatchNormalization gamma,beta,momentum,running_mean,running_var,batch_size,xc,std,dgamma,dbeta,prg,krn1,shape1

#modterm
	HCLReleaseBuffer gamma
	HCLReleaseBuffer beta
	HCLReleaseBuffer running_mean
	HCLReleaseBuffer running_var
	return

#modinit int shape1_,int ccnt,str loadpathname
	shape1=shape1_
	gamma=HCLCreateBuffer(shape1*4)
	beta=HCLCreateBuffer(shape1*4)
	running_mean=HCLCreateBuffer(shape1*4)
	running_var=HCLCreateBuffer(shape1*4)

	nploadm ""+loadpathname+"bn"+str(ccnt)+"_gamma.npy",gamma
	nploadm ""+loadpathname+"bn"+str(ccnt)+"_beta.npy" ,beta
	nploadm ""+loadpathname+"bn"+str(ccnt)+"_running_mean.npy",running_mean
	nploadm ""+loadpathname+"bn"+str(ccnt)+"_running_var.npy",running_var

	prg=HCLCreateProgramWithSource({"
	__kernel void krn1(__global float *X,__global float *Xout
	,__global float *running_mean,__global float *running_var
	,__global float *gamma,__global float *beta) 
	{
		uint id = get_global_id(0);
		uint id2 = id%"}+str(shape1)+{";
		float x1 = X[id] - running_mean[id2];
		x1 = x1/sqrt(0.0000001+running_var[id2]);
		Xout[id] = gamma[id2]*x1+beta[id2];
	}
	"})
	krn1=HCLCreateKernel(prg,"krn1")
	HCLSetkrns krn1,int64(0),int64(0),running_mean,running_var,gamma,beta
	return
	
//BNforwrd BNmodule変数,Matmodule変数in,Matmodule変数out,train_flg
#modfunc BNforwrd var Matmin,var Matmout,int train_flg
	
	if train_flg==1{//学習時
		/*
            # 正規化の計算
            mu = x.mean(axis=0)  # 平均
            xc = x - mu  # 偏差
            var = np.mean(xc ** 2, axis=0)  # 分散
            std = np.sqrt(var + 10e-7)  # 標準偏差
            xn = xc / std  # 標準化:式(6.7)

            # 計算結果を(逆伝播用に)インスタンス変数として保存
            self.batch_size = x.shape[0]
            self.xc = xc  # 偏差
            self.xn = xn  # 標準化データ
            self.std = std  # 標準偏差
            self.running_mean = self.momentum * self.running_mean + (1 - self.momentum) * mu  # 過去の平均の情報
            self.running_var = self.momentum * self.running_var + (1 - self.momentum) * var  # 過去の分散の情報
			//# 再変換
			//out = self.gamma * xn + self.beta  # 式(6.8)
		*/
	}else{  //# テスト時
		/*
            xc = x - self.running_mean
            xn = xc / np.sqrt(self.running_var + 10e-7)  # 標準化:式(6.7')
			//# 再変換
			//out = self.gamma * xn + self.beta  # 式(6.8)
		*/
		rawnum=HCLBLAS_Get2DShape(Matmin,0)
		colnum=HCLBLAS_Get2DShape(Matmin,1)
		HCLSetkrns krn1,Matmin,Matmout
		HCLDokrn1_sub krn1,int(rawnum*colnum),64
	}
	return

#global